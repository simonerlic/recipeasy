////  RecipeHistoryView.swift//  recipeasy////  Created by Simon Erlic on 2024-11-17.//import SwiftUIimport SwiftDatastruct CookingHistoryView: View {    @Environment(\.modelContext) private var modelContext    @Bindable var recipe: Recipe    @State private var showingAddEntry = false    @State private var isEditing = false        @State private var maxCardHeight: CGFloat = 200        private var sortedEntries: [RecipeAttempt] {        recipe.attempts.sorted { $0.dateCreated > $1.dateCreated }    }        var body: some View {        VStack(alignment: .leading, spacing: 16) {            HStack {                SectionHeader(title: "Cooking History")                Spacer()                if !sortedEntries.isEmpty {                    Button(action: { isEditing.toggle() }) {                        Text(isEditing ? "Done" : "Edit")                    }                    .animation(nil, value: isEditing)                }            }                        if sortedEntries.isEmpty {                Text("No entries yet")                    .foregroundStyle(.secondary)                    .padding(.vertical, 8)            } else {                ScrollView(.horizontal, showsIndicators: false) {                    LazyHStack(spacing: 16) {                        ForEach(sortedEntries) { entry in                            CookingHistoryCard(entry: entry, isEditing: isEditing) {                                deleteEntry(entry)                            }                        }                    }                }            }                        Button(action: { showingAddEntry = true }) {                Label("Add Entry", systemImage: "plus.circle")            }        }        .sheet(isPresented: $showingAddEntry) {            NavigationStack {                AddHistoryEntryView(recipe: recipe)            }            .presentationDragIndicator(.visible)        }    }        private func deleteEntry(_ entry: RecipeAttempt) {        withAnimation {            recipe.attempts.removeAll { $0.id == entry.id }            modelContext.delete(entry)        }    }}struct CookingHistoryCard: View {    let entry: RecipeAttempt    let isEditing: Bool    let onDelete: () -> Void        @State private var offset: CGFloat = 0    @State private var showingDeleteConfirmation = false        var body: some View {        CardView {            ZStack(alignment: .topTrailing) {                // Delete button that shows when editing                if isEditing {                    Button(action: { showingDeleteConfirmation = true }) {                        Image(systemName: "minus.circle.fill")                            .font(.title2)                            .foregroundStyle(.white, .red)                            .padding(8)                    }                    .zIndex(1)                }                                // Main content                VStack(alignment: .leading, spacing: 0) {  // Remove spacing here                    if let imageData = entry.imageData,                       let uiImage = UIImage(data: imageData) {                        Image(uiImage: uiImage)                            .resizable()                            .scaledToFill()                            .frame(width: 200, height: 150)                            .clipped()                    }                                        VStack(alignment: .leading, spacing: 8) {                        HStack {                            Text(entry.dateCreated.formatted(date: .abbreviated, time: .omitted))                                .font(.caption)                                .foregroundStyle(.secondary)                                                        Spacer()                                                        if let rating = entry.rating {                                HStack(spacing: 2) {                                    ForEach(0..<5) { index in                                        Image(systemName: index < rating ? "star.fill" : "star")                                            .foregroundStyle(.yellow)                                            .font(.caption)                                    }                                }                            }                        }                                                if !entry.notes.isEmpty {                            Text(entry.notes)                                .font(.callout)                                .lineLimit(4)                        }                    }                    .padding(.horizontal)                    .padding(.vertical, 12)  // Consistent vertical padding                }            }        }        .frame(width: 200, height: entry.notes.isEmpty ? 200 : 240)  // Fixed height based on content        .offset(x: offset)        .alert("Delete entry?", isPresented: $showingDeleteConfirmation) {            Button("Delete", role: .destructive, action: onDelete)            Button("Cancel", role: .cancel) { }        } message: {            Text("This action cannot be undone.")        }    }}struct AddHistoryEntryView: View {    @Environment(\.modelContext) private var modelContext    @Environment(\.dismiss) private var dismiss    @Bindable var recipe: Recipe        @State private var notes = ""    @State private var imageData: Data?    @State private var rating: Int?        var isFormValid: Bool {        !notes.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&        imageData != nil &&        rating != nil    }        var body: some View {        Form {            Section(header: Text("Photo (Required)")) {                ImagePicker(imageData: $imageData, title: "Finished Dish")                if imageData == nil {                    Text("Please add a photo")                        .foregroundStyle(.red)                        .font(.caption)                }            }                        Section(header: Text("Rating (Required)")) {                HStack {                    ForEach(1...5, id: \.self) { star in                        Image(systemName: (rating ?? 0) >= star ? "star.fill" : "star")                            .foregroundStyle(rating == nil ? .gray : .yellow)                            .onTapGesture {                                rating = star                            }                    }                }                .padding(.vertical, 4)                                if rating == nil {                    Text("Please select a rating")                        .foregroundStyle(.red)                        .font(.caption)                }            }                        Section(header: Text("Notes (Required)")) {                TextField("How did it turn out?", text: $notes, axis: .vertical)                    .lineLimit(3...6)                if notes.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {                    Text("Please add some notes")                        .foregroundStyle(.red)                        .font(.caption)                }            }        }        .navigationTitle("Add Entry")        .navigationBarTitleDisplayMode(.inline)        .toolbar {            ToolbarItem(placement: .navigationBarLeading) {                Button("Cancel") {                    dismiss()                }            }            ToolbarItem(placement: .navigationBarTrailing) {                Button("Save") {                    withAnimation {                        let entry = RecipeAttempt(                            recipe: recipe,                            notes: notes.trimmingCharacters(in: .whitespacesAndNewlines),                            imageData: imageData,                            rating: rating                        )                        modelContext.insert(entry)                        recipe.attempts.append(entry)                        dismiss()                    }                }                .disabled(!isFormValid)            }        }    }}